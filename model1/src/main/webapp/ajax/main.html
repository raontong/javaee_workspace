<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<style>
    .container{
        width: 650px;
        height: 500px;
        background-color: aliceblue;
        margin: auto;
    }
    .aside{
        width: 150px;
        height: 100%;
        background-color: rgb(40, 77, 109);
        float: left;
    }
    .aside input{
        width: 90%;
    }
    .aside button{
        width: 50%;
    }
    .content{
        width: 500px;
        height: 100%;
        background-color: aliceblue;
        float: left;
    }
</style>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script>
/*
목폭을 출력하는 작업은 꼭 등록할때만이 아니라, 유저가 처음 브라우저로 main.html 요청한 시점부터도 목록이 나와야 하므로,
목록 기능은 재사용가능성이 높다.. 따라서 함수로 별도로 정의
*/
function render(list){
	   console.log("전달받은 배열은 " + list);
	   // ★ 랜더링 작업은 상당히 고달픈 작업이면서 시간이 많이 걸림. 따라서 이와 관련되어 나온 기술이 Vue, React.js..
	   // document.querySelector(".content").innerHTML="<table>";
	let tag = "<table width='100%' border='1px'>";
	tag += "<head>";
	tag += "<tr>";
	tag += "<th>ID</th>";
	tag += "<th>Name</th>";
	tag += "<th>Email</th>";
	tag += "</tr>";
	tag += "</head>";
	tag += "<tbody>";
	for(let i=0; i < list.length; i++)   {
		let obj= list[i];
		tag += "<tr>";
	    tag += "<th>"+obj.id+"</th>";
	    tag += "<th>"+obj.name+"</th>";
		tag += "<th>"+obj.email+"</th>";
	    tag += "</tr>";
	   	}
	   	tag += "</tbody>";   
	   	tag += "</table>";
	   
	   	$(".content").html(tag);
	}

// 서버의 목록 요청(비동기적)
function getList(){
	// 비동기적 요청을 담당하는 XMLHttpRequest 객체를 사용
	let xhttp= new XMLHttpRequest();
	
	// 서버의 응답이 도달하면 지정한 익명함수가 호출(by javascript)
	xhttp.onload=function(){
		
		// 서버에서 전송한 문자열 받기!
		console.log("서버로 부터 받은 문자열은", this.responseText);
		
		//서버에서 전송ㅎ안 json 문자열을 피싱하여 화면에 랜더링!!
		console.log("서버가 응답한 데이터는", this.responseText);
		
		// 파싱 시 주의점? 반드시 문자열이 JSON표기법을 따른 것만이 파싱이 성공할수 있다
		let memberList=JSON.parse(this.responseText); 
				
		// 화면에 랜더링함. 객체가 넘어오길  기다림
		render(memberList);
	}
	xhttp.open("GET", "/ajax/async_list.jsp"); // 요청준비
	xhttp.send(); // 여기서 요청발생
}

function regist(){
	// 서버에 요청을 시도하되, 비동기로 요청하자!!
	let xhttp =new XMLHttpRequest(); // js의 비동기 통신 객체
	
	xhttp.onload=function(){
		// 서버에서 응답 정보가 도착하면 호출되는 익명함수 역할로 써는 콜백함수
		console.log("서버에서 보내온 데이터는 ", this.responseText);
		
		// 받아온 데이터는 언제나 문자열 이므로, oop 으로 제어하려면 파싱하자!!
		let memberList=JSON.parse(this.responseText);
		console.log("memberList", memberList);
		
		// 서버에서 가져ㅏ온 데이터를 화면에 출력, 하는데 memberList 로 넘겨받아서
		// getList(memberList);
		console.log("등록완료");
		getList(); // 등록 완료와 동시에 
		
	}
	
	xhttp.open("POST", "/ajax/async_regist.jsp"); //요청 방법 및 요청 주소 지정
	// 전송 시 해더 지정
	xhttp.setRequestHeader("Cotent-type", "application/x-www-form-urlencoded; charset=utf-8"); 
	// 비동기 요청 출발!!~(이때 쵸청 시도자체를 자바스크립트가 하지 않고 브라우저에게 시킴..)
	// 자바스크립트는 응답정보가 올 때까지 대기상태에 빠지지 않고, 자신으 ㅣ다른 일을 할수 있다(비동기),
	// 응답이 올때까지 기다리지 않았기 때문에, 즉 순서를 지키지 않았기 떄무에 비동기방식
	// 브라우저가 응답을 받아오면, 자바스크립트에게 알림.. 이때 자바스크립트의 xmlhttprequest의 onload속성에 지정한
	// 익명함수인 콜백함수를 호출하게 된다...(누가?? js가)
	xhttp.send("id="+$("input[name='id']").val()+"&name="+$("input[name='name']").val()+"&email="+$("input[name='email']").val()); // 요청시작
}	 
	// onload
	$(()=>{
        // 동기 버튼에 클릭 이벤트 연결
        $("button").click(()=>{
        	regist();
            // alert("동기방식의 요청시도");
    	});       
        getList();
	});
	
</script>
</head>
<body>
	<div class="container">
        <div class="aside">
            <form>
                <input type="text" placeholder="Your ID..." name="id">
                <input type="text" placeholder="Your name..." name="name">
                <input type="text" placeholder="Your email..." name="email">
                <button type="button">등록</button>
            </form>
        </div>
        <div class="content"></div>
    </div>
    
</body>
</html>